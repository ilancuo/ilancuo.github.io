[{"title":"通过代码控制EditText中光标的颜色","date":"2017-12-08T14:30:18.000Z","path":"2017/12/08/通过代码控制EditText中光标的颜色/","text":"如果把项目的主题颜色设置为白色的话，那么输入框的光标也是会跟着变成白色的。现在，本方法通过反射的方式，将光标的颜色更改为与主题色不同的其他颜色，并且提供在布局和代码中的自定义功能。 使用之前的效果 使用之后的效果 首先，自定义一个EditText，继承自AppCompatEditText，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839import android.content.Context;import android.content.res.TypedArray;import android.util.AttributeSet;import android.widget.TextView;import com.ivt.mworkstation.R;import java.lang.reflect.Field;public class MyEditText extends android.support.v7.widget.AppCompatEditText &#123; public MyEditText(Context context) &#123; this(context, null); &#125; public MyEditText(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context, attrs); &#125; private void init(Context context, AttributeSet attrs) &#123; TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.MyEditText); int drawable = a.getResourceId(R.styleable.MyEditText_textCursorDrawable, 0); if (drawable != 0) &#123; setCursorDrawable(drawable); &#125; a.recycle(); &#125; public void setCursorDrawable(int resId) &#123; try &#123; Field setCursor = TextView.class.getDeclaredField(\"mCursorDrawableRes\"); setCursor.setAccessible(true); setCursor.set(this, resId); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 属性文件attrs.xml如下： 123&lt;declare-styleable name=\"MyEditText\"&gt; &lt;attr name=\"textCursorDrawable\" format=\"reference\"/&gt;&lt;/declare-styleable&gt; 接下来是光标的资源文件edit_cursor_color.xml 123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\"&gt; &lt;size android:width=\"1dp\" /&gt; &lt;solid android:color=\"#21ADE3\" /&gt;&lt;/shape&gt; 调用方法（此处为在代码中创建） 12345678910MyEditText editText = new MyEditText(this);LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);params.setMargins(40, 60, 40, 0);editText.setLayoutParams(params);editText.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_VARIATION_PASSWORD);editText.setGravity(Gravity.CENTER);editText.setBackgroundResource(R.drawable.bg_shape_gray_stroke);editText.setCursorDrawable(R.drawable.edit_cursor_color);editText.setFocusable(true);editText.requestFocus();","tags":[{"name":"Android","slug":"Android","permalink":"http://ilancuo.com/tags/Android/"}]},{"title":"Android浮动窗口的实现","date":"2017-06-03T14:04:09.000Z","path":"2017/06/03/Android浮动窗口的实现/","text":"项目中需要用到一个在各个Activity中都显示的录音的悬浮框，刚开始考虑是在BaseActivity中创建，但是后来发现UI给的图是浮动在最上层的样式。因此，通过WindowManager来实现该样式，实现后的效果如图所示： 封装后的完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import android.content.Context;import android.graphics.PixelFormat;import android.view.Gravity;import android.view.LayoutInflater;import android.view.View;import android.view.WindowManager;import android.widget.Toast;import com.ivt.emergency.R;/** * 处理录音弹框的工具类 * Created by Wang.Hongwei on 2017/5/19. */public class WindowHelper &#123; private static WindowHelper mInstance; private WindowManager mWindowManager = null; private View mView; private boolean isShown = false; private WindowHelper() &#123; &#125; public static WindowHelper getInstance() &#123; if (mInstance == null) &#123; synchronized (WindowHelper.class) &#123; if (mInstance == null) &#123; mInstance = new WindowHelper(); &#125; &#125; &#125; return mInstance; &#125; public void showWindow(Context context) &#123; if (isShown) return; isShown = true; Context mContext = context.getApplicationContext(); mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE); mView = setUpView(context); WindowManager.LayoutParams params = new WindowManager.LayoutParams(); params.type = WindowManager.LayoutParams.TYPE_SYSTEM_ALERT; params.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE; params.format = PixelFormat.TRANSLUCENT; params.width = WindowManager.LayoutParams.MATCH_PARENT; params.height = DisplayUtil.dip2px(mContext, 30); params.gravity = Gravity.TOP; params.y = DisplayUtil.dip2px(mContext, 50); mWindowManager.addView(mView, params); &#125; public void hideWindow() &#123; if (isShown &amp;&amp; null != mView) &#123; mWindowManager.removeView(mView); mView = null; isShown = false; &#125; &#125; private View setUpView(final Context context) &#123; View view = LayoutInflater.from(context).inflate(R.layout.window_recording, null); view.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(context, \"点击了Window!\", Toast.LENGTH_SHORT).show(); hideWindow(); &#125; &#125;); return view; &#125; public boolean isShown() &#123; return isShown; &#125;&#125; 布局文件如下： 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/ll_window\" android:layout_width=\"match_parent\" android:layout_height=\"30dip\" android:background=\"#88000000\" android:gravity=\"center_vertical\" android:orientation=\"horizontal\"&gt; &lt;ImageView android:id=\"@+id/iv_recording\" android:layout_width=\"30dip\" android:layout_height=\"30dip\" android:layout_marginStart=\"25dip\" android:contentDescription=\"@null\" android:padding=\"5dip\" android:src=\"@drawable/red_circle\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"10dip\" android:text=\"@string/recording\" /&gt;&lt;/LinearLayout&gt; 引用到的shape资源文件如下： 12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"oval\"&gt; &lt;solid android:color=\"@android:color/holo_red_light\" /&gt; &lt;size android:width=\"100dip\" android:height=\"100dip\" /&gt;&lt;/shape&gt; 最后，记得添加权限： 1&lt;uses-permission android:name=\"android.permission.SYSTEM_ALERT_WINDOW\" /&gt; 如果退出应用时，想在华为、小米之类的手机上显示悬浮窗，需要在权限设置中打开允许悬浮窗。不然，就只能在应用内显示。","tags":[{"name":"Android","slug":"Android","permalink":"http://ilancuo.com/tags/Android/"},{"name":"自定义View","slug":"自定义View","permalink":"http://ilancuo.com/tags/自定义View/"},{"name":"WindowManager","slug":"WindowManager","permalink":"http://ilancuo.com/tags/WindowManager/"}]},{"title":"Android自定义Dialog的实现","date":"2017-05-11T15:09:32.000Z","path":"2017/05/11/Android自定义Dialog的实现/","text":"为了在不同版本系统下UI的统一，通常要用到自定义控件。其中，自定义Dialog是一个比较常用的功能。本文采用跟系统一致的方法即：建造者模式来实现自定义的Dialog。 建立一个类，继承自Dialog，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143import android.app.Dialog;import android.content.Context;import android.content.DialogInterface;import android.support.annotation.NonNull;import android.support.annotation.StyleRes;import android.text.TextUtils;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.view.WindowManager;import android.widget.TextView;/** * 自定义对话框 * Created by Wang.Hongwei on 2017/5/10. */public class MDialog extends Dialog &#123; public MDialog(@NonNull Context context) &#123; super(context); &#125; public MDialog(@NonNull Context context, @StyleRes int themeResId) &#123; super(context, themeResId); &#125; public static class Builder &#123; private Context context; private String title; private String message; private String positiveTxt; private String negativeTxt; private boolean cancelable; private OnClickListener positiveListener; private OnClickListener negativeListener; public Builder(Context context) &#123; this.context = context; &#125; public Builder setTitle(String title) &#123; this.title = title; return this; &#125; public Builder setTitle(int title) &#123; this.title = context.getString(title); return this; &#125; public Builder setMessage(String message) &#123; this.message = message; return this; &#125; public Builder setMessage(int message) &#123; this.message = context.getString(message); return this; &#125; public Builder setCancelable(boolean cancelable) &#123; this.cancelable = cancelable; return this; &#125; public Builder setPositiveButton(String positiveTxt, OnClickListener positiveListener) &#123; this.positiveTxt = positiveTxt; this.positiveListener = positiveListener; return this; &#125; public Builder setPositiveButton(int positiveTxt, OnClickListener positiveListener) &#123; this.positiveTxt = context.getString(positiveTxt); this.positiveListener = positiveListener; return this; &#125; public Builder setNegativeButton(String negativeTxt, OnClickListener negativeListener) &#123; this.negativeTxt = negativeTxt; this.negativeListener = negativeListener; return this; &#125; public Builder setNegativeButton(int negativeTxt, OnClickListener negativeListener) &#123; this.negativeTxt = context.getString(negativeTxt); this.negativeListener = negativeListener; return this; &#125; public MDialog build() &#123; LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); final MDialog dialog = new MDialog(context, R.style.dialog); dialog.setCancelable(cancelable); View layout = inflater.inflate(R.layout.dialog, null); dialog.addContentView(layout, new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)); if (!TextUtils.isEmpty(positiveTxt)) &#123; ((TextView) layout.findViewById(R.id.btn_ok)).setText(positiveTxt); if (positiveListener != null) &#123; (layout.findViewById(R.id.btn_ok)).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; dialog.dismiss(); positiveListener.onClick(dialog, DialogInterface.BUTTON_POSITIVE); &#125; &#125;); &#125; &#125; else &#123; layout.findViewById(R.id.btn_ok).setVisibility(View.GONE); &#125; if (!TextUtils.isEmpty(negativeTxt)) &#123; ((TextView) layout.findViewById(R.id.btn_cancel)).setText(negativeTxt); if (negativeListener != null) &#123; (layout.findViewById(R.id.btn_cancel)).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; dialog.dismiss(); negativeListener.onClick(dialog, DialogInterface.BUTTON_NEGATIVE); &#125; &#125;); &#125; &#125; else &#123; layout.findViewById(R.id.btn_cancel).setVisibility(View.GONE); &#125; if (TextUtils.isEmpty(title)) &#123; layout.findViewById(R.id.txt_title).setVisibility(View.GONE); layout.findViewById(R.id.txt_msg).setPadding(0, 100, 0, 100); &#125; else &#123; ((TextView) layout.findViewById(R.id.txt_title)).setText(title); &#125; if (TextUtils.isEmpty(message)) &#123; layout.findViewById(R.id.txt_msg).setVisibility(View.GONE); &#125; else &#123; ((TextView) layout.findViewById(R.id.txt_msg)).setText(message); &#125; WindowManager.LayoutParams params = dialog.getWindow().getAttributes(); params.width = DisplayUtil.getScreenWidth(context) - 100; dialog.setContentView(layout); return dialog; &#125; &#125;&#125; 用到的样式文件为： 123456789&lt;style name=\"dialog\" parent=\"@android:style/Theme.Dialog\"&gt; &lt;item name=\"android:windowFrame\"&gt;@null&lt;/item&gt; &lt;item name=\"android:windowIsFloating\"&gt;true&lt;/item&gt; &lt;item name=\"android:windowIsTranslucent\"&gt;true&lt;/item&gt; &lt;item name=\"android:windowNoTitle\"&gt;true&lt;/item&gt; &lt;item name=\"android:background\"&gt;@android:color/transparent&lt;/item&gt; &lt;item name=\"android:windowBackground\"&gt;@android:color/transparent&lt;/item&gt; &lt;item name=\"android:backgroundDimAmount\"&gt;0.5&lt;/item&gt;&lt;/style&gt; 用到的布局文件为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"android:id=\"@+id/ll_dialog\"android:layout_width=\"match_parent\"android:layout_height=\"wrap_content\"android:background=\"@drawable/bg_shape_radius\"android:orientation=\"vertical\"&gt;&lt;TextView android:id=\"@+id/txt_title\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:paddingBottom=\"10dp\" android:paddingTop=\"15dp\" android:textColor=\"@color/black\" android:textSize=\"20sp\" /&gt;&lt;TextView android:id=\"@+id/txt_msg\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:paddingBottom=\"15dp\" android:paddingLeft=\"30dp\" android:paddingRight=\"30dp\" android:paddingTop=\"15dp\" android:textColor=\"@color/black\" android:textSize=\"16sp\" /&gt;&lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" android:paddingBottom=\"20dip\"&gt; &lt;TextView android:id=\"@+id/btn_ok\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:gravity=\"center\" android:paddingBottom=\"15dp\" android:paddingTop=\"15dp\" android:text=\"@string/confirm\" android:textColor=\"@drawable/selector_blue_txt_color\" android:textSize=\"16sp\" /&gt; &lt;TextView android:id=\"@+id/btn_cancel\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:gravity=\"center\" android:paddingBottom=\"15dp\" android:paddingTop=\"15dp\" android:text=\"@string/cancel\" android:textColor=\"@android:color/darker_gray\" android:textSize=\"16sp\" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 调用方式： 12345678910111213141516new MDialog.Builder(this) .setTitle(\"确定\") .setMessage(\"您确定要删除该文件？\") .setPositiveButton(\"确定\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; //TODO something &#125; &#125;).setNegativeButton(\"取消\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; //TODO something &#125; &#125;).setCancelable(false) .build() .show();","tags":[{"name":"Android","slug":"Android","permalink":"http://ilancuo.com/tags/Android/"},{"name":"自定义View","slug":"自定义View","permalink":"http://ilancuo.com/tags/自定义View/"}]},{"title":"AppCompatActivity的动画处理","date":"2017-04-26T15:18:11.000Z","path":"2017/04/26/AppCompatActivity的动画处理/","text":"对动画处理一直不太擅长，就今天遇见的几个问题，做下笔记。 要做一个从底部弹出、并且从底部消失的Activity，现准备动画文件如下： in_from_bottom.xml 12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;translate xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"300\" android:fromYDelta=\"100%p\" android:toYDelta=\"0%p\" /&gt; out_to_top.xml 12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;translate xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"300\" android:fromYDelta=\"0%p\" android:toYDelta=\"100%p\" /&gt; 动画此时是能够显示了，不过在界面顶部会有一个黑影一闪而过。原来，要把Activity的theme配置成透明才能不显示黑影。好了，直接配置透明主题的Activity: 1android:theme=\"@android:style/Theme.Translucent\" 这时候，应该没问题了吧？结果一运行： 1java.lang.IllegalStateException: You need to use a Theme.AppCompat theme (or descendant) with this activity. 这个呢，大概意思是说：Activity是从AppCompatActivity继承来的，所以要用Theme.AppCompat包下的主题，可是：AppCompat包下根本没有透明的主题好吧…… 采用自定义的主题样式： 12345&lt;style name=\"AppTheme.Transparent\" parent=\"AppTheme\"&gt; &lt;item name=\"android:windowNoTitle\"&gt;true&lt;/item&gt; &lt;item name=\"android:windowBackground\"&gt;@android:color/transparent&lt;/item&gt; &lt;item name=\"android:windowIsTranslucent\"&gt;true&lt;/item&gt;&lt;/style&gt; 其中，AppTheme为之前的主题，在清单文件中给Activity设置成这个主题就可以了。","tags":[{"name":"Android","slug":"Android","permalink":"http://ilancuo.com/tags/Android/"},{"name":"动画","slug":"动画","permalink":"http://ilancuo.com/tags/动画/"}]},{"title":"Android中使用IntDef代替Enum的方案","date":"2017-03-06T13:29:59.000Z","path":"2017/03/06/Android中使用IntDef代替Enum的方案/","text":"如果定义一个只有有限个输入的方法，通常的情况便是采用枚举。但是官方文档说明，Android开发，应该避免使用Enum，因为相比静态常量Enum会花费两倍以上的内存。因而推出了IntDef和StringDef（这里我们不讨论使用常量的方法） 枚举的使用方法： 12345678910111213public enum Season &#123; SPRING, SUMMER, AUTUMN, WINTER&#125;private Season season = Season.WINTER;public Season getSeason() &#123; return season;&#125;public void setSeason(Season season) &#123; this.season = season;&#125; 在这里，setSeason()方法，只能接收Seanson.SPRING、Season.SUMMER、Season.AUTUMN、Season.WINTER四个参数。 采用IntDef/StringDef修改过的方法： 123456789101112131415161718public static final int SPRING = 0;public static final int SUMMER = 1;public static final int AUTUMN = 2;public static final int WINTER = 3;@IntDef(&#123;SPRING, SUMMER, AUTUMN, WINTER&#125;)public @interface Season &#123;&#125;@Season int current = SPRING;public @Season int getCurrent() &#123; return current;&#125;public void setCurrent(@Season int current) &#123; this.current = current;&#125; [注意]采用这种方法需要引入annotations包： 1compile 'com.android.support:support-annotations:22.0.0' 如果导入过com.android.support:appcompat-v7，就不需要导入annotations包了。","tags":[{"name":"Android","slug":"Android","permalink":"http://ilancuo.com/tags/Android/"},{"name":"IntDef","slug":"IntDef","permalink":"http://ilancuo.com/tags/IntDef/"},{"name":"Enum","slug":"Enum","permalink":"http://ilancuo.com/tags/Enum/"}]},{"title":"Retrofit在Android中的使用","date":"2017-03-02T13:31:18.000Z","path":"2017/03/02/Retrofit在Android中的使用/","text":"导入Retrofit和Gson Convertor（Gson Convertor或者其他，可以根据自己的需求进行选择）的包，这两个包版本必须一致： 12compile 'com.squareup.retrofit2:retrofit:2.2.0'compile 'com.squareup.retrofit2:converter-gson:2.2.0' 创建网络访问接口： 1234public interface GitHubService &#123; @GET(\"users/&#123;user&#125;/repos\") Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(\"user\") String user);&#125; 构建Retrofit实例： 1234Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://api.github.com/\") .build();GitHubService service = retrofit.create(GitHubService.class); 调用，共有两种调用方式：同步、异步 同步调用： 12Call&lt;List&lt;Repo&gt;&gt; call = service.listRepos(\"ilancuo\");List&lt;Repo&gt; repos = call.execute().body; 注意，同步调用时候，必须放在子线程中进行； 异步调用： 1234567891011call.enqueue(new Callback&lt;Repo&gt;() &#123; @Override public void onResponse(Call&lt;Repo&gt; call, Response&lt;Repo&gt; response) &#123; Log.e(TAG, response.body().toString()); &#125; @Override public void onFailure(Call&lt;Repo&gt; call, Throwable t) &#123; Log.e(TAG, t.getMessage()); &#125;&#125;); 取消正在进行的请求： 1call.cancel(); 构建自定义的Interceptor: 1234567891011121314public class CustomInterceptor implements Interceptor &#123; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); HttpUrl httpUrl = request .url() .newBuilder() .addQueryParameter(\"token\", \"tokenValue\") //这里可以添加部分公共参数，比如此处的token .build(); request = request.newBuilder().url(httpUrl).build(); return chain.proceed(request); &#125;&#125; 自定义Interceptor的使用： 1234567891011121314151617181920//自定义日志过滤器HttpLoggingInterceptor loggingInterceptor = new HttpLoggingInterceptor(new HttpLoggingInterceptor.Logger() &#123; @Override public void log(String message) &#123; Log.e(\"Retrofit\", message); &#125; &#125;);loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);// End of 自定义日志过滤器OkHttpClient client = new OkHttpClient() .newBuilder() .addInterceptor(loggingInterceptor) //使用日志过滤器 .addInterceptor(new CustomInterceptor()) //使用自定义过滤器 .build(); Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://api.github.com/\") .addConverterFactory(GsonConverterFactory.create()) .client(client) .build(); 自定义日志过滤器需要添加以下依赖： 1compile 'com.squareup.okhttp3:logging-interceptor:3.6.0' [注]本文只简单写了一个简单的Get请求，对整体流程做一个大概的把握。其他请参考Retrofit官网。","tags":[{"name":"Android","slug":"Android","permalink":"http://ilancuo.com/tags/Android/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://ilancuo.com/tags/Retrofit/"}]},{"title":"Android项目中使用Lambda","date":"2017-02-28T12:00:50.000Z","path":"2017/02/28/Android项目中使用Lambda/","text":"先在项目根目录下的build.gradle文件中的dependencies节点下添加： 1classpath 'me.tatarka:gradle-retrolambda:3.2.0' 在moudule中的build.gradle文件中添加： 1apply plugin: 'me.tatarka.retrolambda' 在module中的build.gradle文件中的android节点下添加： 1234compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8&#125; 使用方法如下： 在匿名内部类构造方法无参数的时候使用： 1new Thread(() -&gt; Log.e(TAG, \"Hello, this is thread.\")); 在匿名内部类的的构造方法中含有一个参数的时候使用： 12findViewById(R.id.btn).setOnClickListener(v -&gt; Toast.makeText(MainActivity.this, \"This is Toast\", Toast.LENGTH_SHORT).show()); 在匿名内部类的的构造方法中含有两个或多个个参数的时候使用： 1234((CheckBox) findViewById(R.id.cb)).setOnCheckedChangeListener(((buttonView, isChecked) -&gt; &#123; Log.e(TAG, \"buttonId: \" + buttonView.getId() + \"\"); Log.e(TAG, \"isChecked: \" + buttonView.isChecked() + \"\");&#125;));","tags":[{"name":"Android","slug":"Android","permalink":"http://ilancuo.com/tags/Android/"},{"name":"Lambda","slug":"Lambda","permalink":"http://ilancuo.com/tags/Lambda/"}]},{"title":"Android导出数据到Excel的通用处理","date":"2017-02-20T15:06:32.000Z","path":"2017/02/20/Android导出数据到Excel的通用处理/","text":"通过gradle安装Apache的poi，采用的版本为当前最新版3.16-beta2: 1compile 'org.apache.poi:poi:3.16-beta2' 要添加表头，另外有些字段需要忽略，因此通过自定义注解对数据进行规范。注解类代码如下： 123456789@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)public @interface ExcelAttribute &#123; String desc(); int col() default 0;&#125; 在该注解中，我们定义了两个量：desc和col。desc为该字段的描述，即为：表头；col为该字段在生成Excel文件中的列； 在实体类中使用该注解： 12345678910111213141516171819//User.java @ExcelAttribute(desc = \"ID\", col = 0)private String id;@ExcelAttribute(desc = \"姓名\", col = 1)private String name;@ExcelAttribute(desc = \"年龄\", col = 2)private String age;@ExcelAttribute(desc = \"电话\", col = 3)private String phone;@ExcelAttribute(desc = \"省/直辖市/自治区\", col = 4)private String province;@ExcelAttribute(desc = \"市\", col = 5)private String city;@ExcelAttribute(desc = \"区\", col = 6)private String area;private String school; //该字段没有使用注解，表示Excel中不需要该字段 //Constructor、Getter、Setter方法 略 采用反射的方式拿到注解中的描述和对象的值，生成xml即可，完整的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import android.os.Environment;import org.apache.poi.hssf.usermodel.HSSFWorkbook;import org.apache.poi.ss.usermodel.Cell;import org.apache.poi.ss.usermodel.Row;import org.apache.poi.ss.usermodel.Sheet;import org.apache.poi.ss.usermodel.Workbook;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.lang.reflect.Field;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;/** * 导出Excel文件 * * Created ilancuo on 2017/2/7. */public class ExcelUtil &#123; private static String PATH = Environment.getExternalStorageDirectory().getAbsolutePath(); public static &lt;T&gt; boolean export(List&lt;T&gt; t, String fileName) &#123; if (t == null || t.size() == 0) return false; Workbook workbook = new HSSFWorkbook(); //创建Excel Sheet sheet = workbook.createSheet(); //创建Sheet List&lt;Map&lt;Integer, String&gt;&gt; list = new ArrayList&lt;&gt;(); Map&lt;Integer, String&gt; titleMap = new HashMap&lt;&gt;(); //构建表头 T tt = t.get(0); Field[] fields = tt.getClass().getDeclaredFields(); for (Field field : fields) &#123; field.setAccessible(true); ExcelAttribute attribute = field.getAnnotation(ExcelAttribute.class); if (attribute != null) &#123; titleMap.put(attribute.col(), attribute.desc()); //key为注解中的col，value为注解中的desc &#125; &#125; list.add(titleMap); for (int i = 0; i &lt; t.size(); i++) &#123; //构建表的数据 Field[] fs = t.get(i).getClass().getDeclaredFields(); Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); for (Field f : fs) &#123; f.setAccessible(true); ExcelAttribute attr = f.getAnnotation(ExcelAttribute.class); if (attr != null) &#123; try &#123; map.put(attr.col(), (String) f.get(t.get(i))); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; &#125; list.add(map); &#125; for (int i = 0; i &lt; list.size(); i++) &#123; Row row = sheet.createRow(i); Map&lt;Integer, String&gt; cMap = list.get(i); for (int j = 0; j &lt; cMap.size(); j++) &#123; String value = cMap.get(j); Cell cell = row.createCell(j); cell.setCellValue(value); &#125; &#125; try &#123; File file = new File(PATH + File.separator + fileName); if (file.exists()) file.delete(); FileOutputStream fos = new FileOutputStream(file); workbook.write(fos); fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return true; &#125;&#125; 注意：别忘了添加读写SD卡的权限 1&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt;","tags":[{"name":"Android","slug":"Android","permalink":"http://ilancuo.com/tags/Android/"},{"name":"Excel","slug":"Excel","permalink":"http://ilancuo.com/tags/Excel/"}]},{"title":"Android读取Properties属性文件","date":"2017-02-17T15:15:18.000Z","path":"2017/02/17/Android读取Properties属性文件/","text":"目的：对网络请求的状态码进行统一管理 在assets文件夹中创建code.properties文件； 按照key=value的形式进行存储数据，例如： 1231001=用户名为空1002=密码为空1003=用户名或密码错误 读取properties文件，代码如下： 12345678910111213public static String getConByCode(Context context, int code) &#123; Properties properties = new Properties(); try &#123; InputStream in = new BufferedInputStream(context.getAssets().open(\"code.properties\")); properties.load(in); String result = properties.getProperty(String.valueOf(code)); in.close(); return result; &#125; catch (IOException e) &#123; e.printStackTrace(); return \"\"; &#125;&#125; 经测试，存在中文乱码的情况，后来找到原因：Properties 默认是按ISO-8859-1读取的，因此有两种解决方案： 直接以Unicode的方式存储数据，该方法读取出来的中文没有任何问题，但是使用之前需要转化一下；code.properties文件形式如下： 1231001=\\u7528\\u6237\\u540d\\u4e3a\\u7a7a1002=\\u5bc6\\u7801\\u4e3a\\u7a7a1003=\\u7528\\u6237\\u540d\\u6216\\u5bc6\\u7801\\u9519\\u8bef 修改返回结果的方法为： 1result = new String(result.getBytes(\"ISO-8859-1\"), \"UTF-8\");","tags":[{"name":"Android","slug":"Android","permalink":"http://ilancuo.com/tags/Android/"},{"name":"Properties","slug":"Properties","permalink":"http://ilancuo.com/tags/Properties/"}]},{"title":"Android绘制可缩放、移动的矩形分析","date":"2017-02-17T15:09:56.000Z","path":"2017/02/17/Android绘制可缩放、移动的矩形分析/","text":"手指落下的坐标为矩形的一个顶点，然后手指移动，移动的终点（即：手指抬起的点）为该顶点的对角顶点，矩形绘制完成； 点击四个顶点中的某一个时，对矩形的宽、高同时进行缩放（即：对该顶点进行位移操作，其他顶点不变）； 点击每条边的时候，对矩形的宽或高进行缩放（即：对当前边进行位移，其他边位置不变）； 点击矩形内部，对矩形进行位移操作； 点击矩形外部，重新绘制矩形； 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182import android.content.Context;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.RectF;import android.util.AttributeSet;import android.view.MotionEvent;import android.view.View;import android.view.ViewConfiguration;/** * 可缩放的矩形 * &lt;p/&gt; * Created by ilancuo on 2017/2/16. */public class ScaledRect extends View &#123; private int mTouchSlop; private float touchX, touchY; //记录上次触摸的点 private float leftX, leftY; //矩形的左上角的点 private float width, height; //矩形的宽和高 private RectF rectF; private Paint linePaint; private Position position = Position.OUTER; private static final float touchWidth = 20; //缩放时触摸区域的有效高度 /** * 点击位置 */ private enum Position &#123; LEFT, TOP, RIGHT, BOTTOM, CENTER, LEFT_TOP, RIGHT_TOP, RIGHT_BOTTOM, LEFT_BOTTOM, OUTER &#125; public ScaledRect(Context context) &#123; this(context, null); &#125; public ScaledRect(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public ScaledRect(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; initSlop(); initLinePaint(); rectF = new RectF(); &#125; private void initLinePaint() &#123; linePaint = new Paint(); linePaint.setStrokeWidth(1f); linePaint.setStyle(Paint.Style.STROKE); linePaint.setColor(Color.BLUE); &#125; private void initSlop() &#123; final ViewConfiguration configuration = ViewConfiguration .get(getContext()); mTouchSlop = configuration.getScaledTouchSlop(); &#125; @Override protected void onDraw(Canvas canvas) &#123; RectF tempRectF = new RectF(rectF); tempRectF.sort(); canvas.drawRect(tempRectF, linePaint); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getActionMasked()) &#123; case MotionEvent.ACTION_DOWN: float currentX = event.getX(); float currentY = event.getY(); touchX = currentX; touchY = currentY; if (currentX &gt; leftX - touchWidth &amp;&amp; currentX &lt; leftX + touchWidth &amp;&amp; currentY &gt; leftY - touchWidth &amp;&amp; currentY &lt; leftY + touchWidth) &#123; //左上角区域 position = Position.LEFT_TOP; &#125; else if (currentX &gt; leftX + width - touchWidth &amp;&amp; currentX &lt; leftX + width + touchWidth &amp;&amp; currentY &gt; leftY - touchWidth &amp;&amp; currentY &lt; leftY + touchWidth) &#123; //右上角区域 position = Position.RIGHT_TOP; &#125; else if (currentX &gt; leftX - touchWidth &amp;&amp; currentX &lt; leftX + touchWidth &amp;&amp; currentY &gt; leftY + height - touchWidth &amp;&amp; currentY &lt; leftY + height + touchWidth) &#123; //左下角区域 position = Position.LEFT_BOTTOM; &#125; else if (currentX &gt; leftX + width - touchWidth &amp;&amp; currentX &lt; leftX + width + touchWidth &amp;&amp; currentY &gt; leftY + height - touchWidth &amp;&amp; currentX &lt; leftX + width + touchWidth) &#123; //右下角区域 position = Position.RIGHT_BOTTOM; &#125; else if (currentX &gt; leftX - touchWidth &amp;&amp; currentX &lt; leftX + touchWidth &amp;&amp; currentY &gt; leftY + touchWidth &amp;&amp; currentY &lt; leftY + height + touchWidth) &#123; //左侧 position = Position.LEFT; &#125; else if (currentX &gt; leftX + touchWidth &amp;&amp; currentX &lt; leftX + width - touchWidth &amp;&amp; currentY &gt; leftY - touchWidth &amp;&amp; currentY &lt; leftY + touchWidth) &#123; //上方 position = Position.TOP; &#125; else if (currentX &gt; leftX + width - touchWidth &amp;&amp; currentX &lt; leftX + width + touchWidth &amp;&amp; currentY &gt; leftY + touchWidth &amp;&amp; currentY &lt; leftY + width - touchWidth) &#123; //右侧 position = Position.RIGHT; &#125; else if (currentX &gt; leftX + touchWidth &amp;&amp; currentX &lt; leftX + width + touchWidth &amp;&amp; currentY &gt; leftY + height - touchWidth &amp;&amp; currentY &lt; leftY + height + touchWidth) &#123; //下方 position = Position.BOTTOM; &#125; else if (currentX &gt; leftX + touchWidth &amp;&amp; currentX &lt; leftX + width - touchWidth &amp;&amp; currentY &gt; leftY + touchWidth &amp;&amp; currentY &lt; leftY + height - touchWidth) &#123; //中间区域 position = Position.CENTER; &#125; else &#123; //外部区域 rectF.setEmpty(); leftX = event.getX(); leftY = event.getY(); rectF.set(new RectF(currentX, currentY, currentX, currentY)); position = Position.OUTER; &#125; break; case MotionEvent.ACTION_MOVE: switch (position) &#123; case LEFT_TOP: rectF.left = event.getX(); rectF.top = event.getY(); break; case LEFT_BOTTOM: rectF.left = event.getX(); rectF.bottom = event.getY(); break; case RIGHT_TOP: rectF.right = event.getX(); rectF.top = event.getY(); break; case RIGHT_BOTTOM: rectF.right = event.getX(); rectF.bottom = event.getY(); break; case LEFT: rectF.left = event.getX(); break; case TOP: rectF.top = event.getY(); break; case RIGHT: rectF.right = event.getX(); break; case BOTTOM: rectF.bottom = event.getY(); break; case CENTER: //矩形内，移动矩形 float tdx = event.getX() - touchX; float tdy = event.getY() - touchY; rectF.left = leftX + tdx; rectF.top = leftY + tdy; rectF.right = rectF.left + width; rectF.bottom = rectF.top + height; break; default: //矩形外，重新绘制矩形 float dx = event.getX() - leftX; float dy = event.getY() - leftY; float absX = Math.abs(dx); float absY = Math.abs(dy); double sqrt = Math.sqrt(absX * absX + absY * absY); if (sqrt &gt; mTouchSlop) &#123; //矩形可见 rectF.right = event.getX(); rectF.bottom = event.getY(); &#125; break; &#125; postInvalidate(); break; case MotionEvent.ACTION_UP: rectF.sort(); leftX = rectF.left; leftY = rectF.top; width = rectF.width(); height = rectF.height(); break; &#125; return true; &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://ilancuo.com/tags/Android/"},{"name":"自定义View","slug":"自定义View","permalink":"http://ilancuo.com/tags/自定义View/"}]},{"title":"Mac下使用Flask框架开发Python","date":"2017-01-18T14:46:25.000Z","path":"2017/01/18/Mac下使用Flask框架开发Python/","text":"安装pyCharm，官网下载地址 首先安装virtualenv，命令如下： 123sudo easy_install virtualenv 或者sudo pip install virtualenv 创建自己的环境： 123mkdir pyProcd pyProvirtualenv venv 激活环境 1. venv/bin/activate #注意：\".\"和\"venv\"之间有一个空格 安装Flask 1pip install Flask 打开pyCharm，创建一个新的项目，在Interpreter后面点击齿轮按钮，选择Create VirtualEnv，选择刚刚创建目录下的.../pyPro/venv/bin/python，点击OK即可，成功之后的效果如图所示： 在pyCharm中创建Hello.py文件： 123456789from flask import Flaskapp = Flask(__name__)@app.route('/')def hello(): return 'Hello, World!'app.run() 运行项目，控制台输出： 12/Users/ilancuo/PyPro/venv/bin/python /Users/ilancuo/PycharmProjects/FlaskTest/Hello.py* Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) 表示项目运行成功，这时候打开浏览器访问： 123http://127.0.0.1:5000或者http://localhost:5000 就会在网页上显示：Hello, World!。 至此，项目配置成功。","tags":[{"name":"Python","slug":"Python","permalink":"http://ilancuo.com/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"http://ilancuo.com/tags/Flask/"},{"name":"pyCharm","slug":"pyCharm","permalink":"http://ilancuo.com/tags/pyCharm/"}]},{"title":"Android中采用xml存储map","date":"2016-12-27T12:49:23.000Z","path":"2016/12/27/Android中采用xml存储map/","text":"在strings.xml中创建如下格式的数据： 1234&lt;string-array name=\"nameValue\"&gt; &lt;item&gt;name|Mike&lt;/item&gt; &lt;item&gt;age|18&lt;/item&gt;&lt;/string-array&gt; 使用标准的读取string数组的方式进行读取： 123456789public Map&lt;String, String&gt; getMap() &#123; private String[] arry = getResources().getStringArray(R.array.nameValue); Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); for (String str : mari) &#123; String[] split = str.split(\"\\\\|\"); //注意这一步，将分割线前后的两个字符串分别存储到Key和value中，分割线可自定义 map.put(split[0], split[1]); &#125; return map;&#125; 参考：stackoverflow","tags":[{"name":"Android","slug":"Android","permalink":"http://ilancuo.com/tags/Android/"},{"name":"xml","slug":"xml","permalink":"http://ilancuo.com/tags/xml/"},{"name":"map","slug":"map","permalink":"http://ilancuo.com/tags/map/"}]},{"title":"Android开发中常用的ADB命令","date":"2016-12-25T12:47:56.000Z","path":"2016/12/25/Android开发中常用的ADB命令/","text":"android命令12android list targets #查看可用的Android平台：android list avd #显示系统中全部AVD（模拟器） ADB命令1234567891011121314151617181920212223242526272829303132adb version #查看版本adb install D:\\HelloWorld.apk #安装指定目录中的apk文件adb -s emulator-5554 install HelloWorld.apk #安装应用到指定模拟器adb install -r demo.apk #保留数据和缓存文件，重新安装apkadb install -s demo.apk #安装apk到SD卡adb uninstall -k [包名] #卸载，-k为卸载软件但是保留配置和缓存文件；但是在此命令添加-k参数会报错，可以在adb shell命令中，执行pm uninstall -k [包名]实现相同的功能；adb push &lt;local&gt; &lt;remote&gt; #从本地复制文件到模拟器adb pull &lt;remote&gt; &lt;local&gt; #从模拟器到本地adb get-serialno #获取设备序列号adb devices #查看可用模拟器列表adb shell #进入Shellreboot -p #关机 [shell下命令]adb kill-server/start-server #启动、停止模拟器服务adb logcat -s [tag] #查看LOG信息adb shell cat /sys/class/net/wlan0/address #获取Mac地址adb shell getprop ro.product.model #获取设备型号adb shell getprop ro.build.version.release #查看Android系统版本adb shell wm size #查看屏幕分辨率adb shell wm density #查看屏幕密度adb shell getprop ro.product.cpu.abi #查看连接手机的CPU核心adb shell pm list packages #列出手机装的所有app的包名adb shell pm list packages -s #列出系统应用的包名adb shell pm list packages -3 #第三方应用的包名adb shell pm list packages | grep qq #使用grep过滤adb shell pm clear &lt;packagename&gt; #清除应用数据与缓存adb shell pm list permissions #查询系统中支持的许可列表adb shell am start -n com.ilancuo.demo/.ui.SplashActivity #启动应用adb shell am force-stop &lt;packagename&gt; #强制停止应用adb shell netstat -ano #查看端口占用情况，然后根据PID去任务管理器里面寻找相应的进程adb shell dumpsys activity #ActivityManager 系统服务的相关信息，这些信息包括 Activity，Broadcast，Service 和 ContentProvideradb shell dumpsys meminfo #内存使用信息adb shell dumpsys procstats –hours 3 #查看过去 3 小时内，进程的使用情况 mksdcard命令1mksdcard -l &lt;label&gt; &lt;size&gt; &lt;file&gt; #好处：可以在不同设备之间共享SD卡 SQLite命令12sqlite3 [databasename].db #进入哪个数据库sqlite&gt;.tables #显示所有的表 CMD命令12netstat -a -o 5037 #查看端口占用情况tasklist /fi \"pid eq 5384\" #查看占用该端口的应用[5384为上一步查询出来的PID]","tags":[{"name":"Android","slug":"Android","permalink":"http://ilancuo.com/tags/Android/"},{"name":"ADB","slug":"ADB","permalink":"http://ilancuo.com/tags/ADB/"}]},{"title":"Git的基本用法","date":"2016-12-14T13:04:52.000Z","path":"2016/12/14/Git的基本用法/","text":"初始化Git仓库： 1git init Git配置用户名和邮箱： 12git config --global user.name \"ilancuo\"git config --global user.email \"grandkingwang@gmail.com\" #如果只想在该项目中配置，只需要把--global参数去掉即可 查看Git配置状态： 1git config --list 添加到暂存 123git add hello.txt #添加一个文件#或者git add -A #添加当前目录下的所有文件 提交 1git commit -m \"Initial commit.\" 链接远端仓库 1git remote add origin https://github.com/ilancuo/i.git #通常主远端仓库被起名称origin Push &amp;&amp; Pull 12git pull origin master #第一个参数为远端仓库的名字，第二个参数为分支的名字git push origin master 克隆 1git clone https://github.com/ilancuo/i.git 分支 123456git checkout -b test #该命令相当于以下两条git branch test #创建分支git checkout test #切换分支git branch #查看分支git branch -d test #删除分支git branch merge test #合并到当前分支 回退 123git reset --hard HEAD^ #回退到上一个版本git reset --hard HEAD^^ #回退到上上个版本git reset --hard HEAD~100 #回退到前100个版本 显示日志 12git log #显示完整日志git log --pretty=oneline #单行显示 从回退中恢复 12git reflog #关掉命令行之后获取版本号git reset --hard [版本号] #从回退中恢复 合并分支 1git merge dev #将dev分支合并到master上","tags":[{"name":"Git","slug":"Git","permalink":"http://ilancuo.com/tags/Git/"}]},{"title":"Android简单使用xStream解析、封装xml","date":"2016-12-04T14:45:56.000Z","path":"2016/12/04/Android简单使用xStream解析、封装xml/","text":"需要用到xml与服务端进行通信。由于之前的json数据交换经验，首先Google的是类似Gson的直接解析数据到Bean的工具，经观察，jdk中含有JAXBContext，在Java环境中测试通过之后，将测试用例迁移到Android环境下，报了个NoClassDefFoundError，后来在StackOverFlow上发现此路不通。后来又看到了推荐的XStream，经测试在1.4.8+的版本中也测试不通，可能是版本兼容性的问题，换成1.4.7版本之后，竟然测试通过了。下面是详细的过程： 在build.gradle中添加依赖：123compile ('com.thoughtworks.xstream:xstream:1.4.7') &#123; exclude group: 'xmlpull', module: 'xmlpull'&#125; 建立相应的实体类： 123456789101112public class User &#123; private String username; private String password; private String email; public User(String username, String password, String email) &#123; this.username = username; this.password = password; this.email = email; &#125; // Getter、Setter方法&#125; 直接调用相应的转换方法： 1234User user = new User(\"ilancuo\", \"123456\", \"ilancuo@ilancuo.com\");XStream xStream = new XStream();String xml = xStream.toXML(user);Log.e(TAG, xml); 输出结果为：12345&lt;com.ilancuo.xstreamtest.User&gt; &lt;username&gt;ilancuo&lt;/username&gt; &lt;password&gt;123456&lt;/password&gt; &lt;email&gt;ilancuo@ilancuo.com&lt;/email&gt;&lt;/com.ilancuo.xstreamtest.User&gt; 到这一步为止，实现了从xml到JavaBean的转化。但是由于.Net写的后台，后台要求，根节点不能带包名，并且字段很多是”User.Name”和”User.Password”形式的，但是Java实体类中不能出现这样的属性，只好继续Google。发现可以重新给设置xml中属性的名称：1234xStream.alias(\"User\", User.class); //根节点名称xStream.aliasField(\"User.Name\", User.class, \"username\");xStream.aliasField(\"User.Password\", User.class, \"password\");xStream.aliasField(\"User.Email\", User.class, \"email\"); 输出结果：12345&lt;User&gt; &lt;User.Name&gt;ilancuo&lt;/User.Name&gt; &lt;User.Password&gt;123456&lt;/User.Password&gt; &lt;User.Email&gt;ilancuo@ilancuo.com&lt;/User.Email&gt;&lt;/User&gt; 完美那个单词怎么说来着？Perfect！可以来个简单的封装了。老规矩，先看协议文档，忽然发现，有两个接口返回的每个字段都是“User.Name”形式的，心里暗暗骂了一遍.Net写的后台。并且“xStream.aliasField”是什么鬼？重复性的工作，简直是对程序员的侮辱！可不可以给每个属性都加个注解呢？好吧，继续Google……终于，皇天不负有心人，这时候，我们的User类是这样的了：12345678910111213141516171819@XStreamAlias(\"User\")public class User &#123; @XStreamAlias(\"User.Name\") private String username; @XStreamAlias(\"User.Password\") private String password; @XStreamAlias(\"User.Email\") private String email; public User(String username, String password, String email) &#123; this.username = username; this.password = password; this.email = email; &#125; // Getter、Setter方法&#125; 调用的时候只需要这样就行了12345XStream xStream = new XStream();xStream.autodetectAnnotations(true);xStream.processAnnotations(User.class);String xml = xStream.toXML(user);Log.e(TAG, xml); 此时，输出的结果为：12345&lt;User&gt; &lt;User.Name&gt;ilancuo&lt;/User.Name&gt; &lt;User.Password&gt;123456&lt;/User.Password&gt; &lt;User.Email&gt;gradnkingwang@gmail.com&lt;/User.Email&gt;&lt;/User&gt; 现在才是真正的完美嘛！但是总感觉少了点什么，继续翻协议文档。我擦，xml头没有。好吧，果断字符串拼接啊！有没有更吊的方法呢？还真被我找到了。直接写一个类，继承XStream，然后重写toXML()方法即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344import com.thoughtworks.xstream.XStream;import com.thoughtworks.xstream.io.xml.DomDriver; import java.io.IOException;import java.io.OutputStream;import java.io.Writer; /*** XStream扩展** Created by ilancuo on 2016/11/29.*/public class XStreamImpl extends XStream &#123; public XStreamImpl() &#123; super(new DomDriver(\"utf-8\")); &#125; public String getDeclaration() &#123; return \"&lt;?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\" ?&gt;\\n\"; &#125; @Override public void toXML(Object obj, OutputStream out) &#123; try &#123; String dec = this.getDeclaration(); byte[] byteDec = dec.getBytes(); out.write(byteDec); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; super.toXML(obj, out); &#125; @Override public void toXML(Object obj, Writer out) &#123; try &#123; out.write(getDeclaration()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; super.toXML(obj, out); &#125;&#125; 额，还是拼接。不过，不要在意这些细节。最后一步，简单进行地封装一下：1234567891011121314151617181920212223242526272829303132333435363738import com.thoughtworks.xstream.XStream; /*** XStream解析器** Created by ilancuo on 2016/11/29.*/public class XStreamParser &#123; private static XStreamParser instance; private XStream xStream; private XStreamParser() &#123; xStream = new XStreamImpl(); xStream.autodetectAnnotations(true); &#125; public static XStreamParser getInstance() &#123; if (instance == null) &#123; synchronized (XStreamParser.class) &#123; if (instance == null) &#123; instance = new XStreamParser(); &#125; &#125; &#125; return instance; &#125; public &lt;T&gt; String toXML(T t) &#123; xStream.processAnnotations(t.getClass()); return xStream.toXML(t); &#125; public &lt;T&gt; T fromXML(String xml) &#123; return (T) xStream.fromXML(xml); &#125;&#125; 欢迎各位雅正。","tags":[{"name":"Android","slug":"Android","permalink":"http://ilancuo.com/tags/Android/"},{"name":"xStream","slug":"xStream","permalink":"http://ilancuo.com/tags/xStream/"},{"name":"xml","slug":"xml","permalink":"http://ilancuo.com/tags/xml/"}]}]