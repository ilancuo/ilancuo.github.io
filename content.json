[{"title":"Android导出数据到Excel的通用处理","date":"2017-02-20T15:06:32.000Z","path":"2017/02/20/Android导出数据到Excel的通用处理/","text":"通过gradle安装Apache的poi，采用的版本为当前最新版3.16-beta2: compile &#39;org.apache.poi:poi:3.16-beta2&#39; 要添加表头，另外有些字段需要忽略，因此通过自定义注解对数据进行规范。注解类代码如下： @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) public @interface ExcelAttribute { String desc(); int col() default 0; } 在该注解中，我们定义了两个量：desc和col。desc为该字段的描述，即为：表头；col为该字段在生成Excel文件中的列； 在实体类中使用该注解： //User.java @ExcelAttribute(desc = &quot;ID&quot;, col = 0) private String id; @ExcelAttribute(desc = &quot;姓名&quot;, col = 1) private String name; @ExcelAttribute(desc = &quot;年龄&quot;, col = 2) private String age; @ExcelAttribute(desc = &quot;电话&quot;, col = 3) private String phone; @ExcelAttribute(desc = &quot;省/直辖市/自治区&quot;, col = 4) private String province; @ExcelAttribute(desc = &quot;市&quot;, col = 5) private String city; @ExcelAttribute(desc = &quot;区&quot;, col = 6) private String area; private String school; //该字段没有使用注解，表示Excel中不需要该字段 //Constructor、Getter、Setter方法 略 采用反射的方式拿到注解中的描述和对象的值，生成xml即可，完整的代码如下： import android.os.Environment; import org.apache.poi.hssf.usermodel.HSSFWorkbook; import org.apache.poi.ss.usermodel.Cell; import org.apache.poi.ss.usermodel.Row; import org.apache.poi.ss.usermodel.Sheet; import org.apache.poi.ss.usermodel.Workbook; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.lang.reflect.Field; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; /** * 导出Excel文件 * * Created ilancuo on 2017/2/7. */ public class ExcelUtil { private static String PATH = Environment.getExternalStorageDirectory().getAbsolutePath(); public static &lt;T&gt; boolean export(List&lt;T&gt; t, String fileName) { if (t == null || t.size() == 0) return false; Workbook workbook = new HSSFWorkbook(); //创建Excel Sheet sheet = workbook.createSheet(); //创建Sheet List&lt;Map&lt;Integer, String&gt;&gt; list = new ArrayList&lt;&gt;(); Map&lt;Integer, String&gt; titleMap = new HashMap&lt;&gt;(); //构建表头 T tt = t.get(0); Field[] fields = tt.getClass().getDeclaredFields(); for (Field field : fields) { field.setAccessible(true); ExcelAttribute attribute = field.getAnnotation(ExcelAttribute.class); if (attribute != null) { titleMap.put(attribute.col(), attribute.desc()); //key为注解中的col，value为注解中的desc } } list.add(titleMap); for (int i = 0; i &lt; t.size(); i++) { //构建表的数据 Field[] fs = t.get(i).getClass().getDeclaredFields(); Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); for (Field f : fs) { f.setAccessible(true); ExcelAttribute attr = f.getAnnotation(ExcelAttribute.class); if (attr != null) { try { map.put(attr.col(), (String) f.get(t.get(i))); } catch (IllegalAccessException e) { e.printStackTrace(); } } } list.add(map); } for (int i = 0; i &lt; list.size(); i++) { Row row = sheet.createRow(i); Map&lt;Integer, String&gt; cMap = list.get(i); for (int j = 0; j &lt; cMap.size(); j++) { String value = cMap.get(j); Cell cell = row.createCell(j); cell.setCellValue(value); } } try { File file = new File(PATH + File.separator + fileName); if (file.exists()) file.delete(); FileOutputStream fos = new FileOutputStream(file); workbook.write(fos); fos.close(); } catch (IOException e) { e.printStackTrace(); } return true; } } 注意：别忘了添加读写SD卡的权限 &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;","tags":[{"name":"Android","slug":"Android","permalink":"http://ilancuo.com/tags/Android/"},{"name":"Excel","slug":"Excel","permalink":"http://ilancuo.com/tags/Excel/"}]},{"title":"Android读取Properties属性文件","date":"2017-02-17T15:15:18.000Z","path":"2017/02/17/Android读取Properties属性文件/","text":"目的：对网络请求的状态码进行统一管理 在assets文件夹中创建code.properties文件； 按照key=value的形式进行存储数据，例如： 1001=用户名为空 1002=密码为空 1003=用户名或密码错误 读取properties文件，代码如下： public static String getConByCode(Context context, int code) { Properties properties = new Properties(); try { InputStream in = new BufferedInputStream(context.getAssets().open(&quot;code.properties&quot;)); properties.load(in); String result = properties.getProperty(String.valueOf(code)); in.close(); return result; } catch (IOException e) { e.printStackTrace(); return &quot;&quot;; } } 经测试，存在中文乱码的情况，后来找到原因：Properties 默认是按ISO-8859-1读取的，因此有两种解决方案： 直接以Unicode的方式存储数据，该方法读取出来的中文没有任何问题，但是使用之前需要转化一下；code.properties文件形式如下： 1001=\\u7528\\u6237\\u540d\\u4e3a\\u7a7a 1002=\\u5bc6\\u7801\\u4e3a\\u7a7a 1003=\\u7528\\u6237\\u540d\\u6216\\u5bc6\\u7801\\u9519\\u8bef 修改返回结果的方法为： result = new String(result.getBytes(&quot;ISO-8859-1&quot;), &quot;UTF-8&quot;);","tags":[{"name":"Android","slug":"Android","permalink":"http://ilancuo.com/tags/Android/"},{"name":"Properties","slug":"Properties","permalink":"http://ilancuo.com/tags/Properties/"}]},{"title":"Android绘制可缩放、移动的矩形分析","date":"2017-02-17T15:09:56.000Z","path":"2017/02/17/Android绘制可缩放、移动的矩形分析/","text":"手指落下的坐标为矩形的一个顶点，然后手指移动，移动的终点（即：手指抬起的点）为该顶点的对角顶点，矩形绘制完成； 点击四个顶点中的某一个时，对矩形的宽、高同时进行缩放（即：对该顶点进行位移操作，其他顶点不变）； 点击每条边的时候，对矩形的宽或高进行缩放（即：对当前边进行位移，其他边位置不变）； 点击矩形内部，对矩形进行位移操作； 点击矩形外部，重新绘制矩形； 代码如下： import android.content.Context; import android.graphics.Canvas; import android.graphics.Color; import android.graphics.Paint; import android.graphics.RectF; import android.util.AttributeSet; import android.view.MotionEvent; import android.view.View; import android.view.ViewConfiguration; /** * 可缩放的矩形 * &lt;p/&gt; * Created by ilancuo on 2017/2/16. */ public class ScaledRect extends View { private int mTouchSlop; private float touchX, touchY; //记录上次触摸的点 private float leftX, leftY; //矩形的左上角的点 private float width, height; //矩形的宽和高 private RectF rectF; private Paint linePaint; private Position position = Position.OUTER; private static final float touchWidth = 20; //缩放时触摸区域的有效高度 /** * 点击位置 */ private enum Position { LEFT, TOP, RIGHT, BOTTOM, CENTER, LEFT_TOP, RIGHT_TOP, RIGHT_BOTTOM, LEFT_BOTTOM, OUTER } public ScaledRect(Context context) { this(context, null); } public ScaledRect(Context context, AttributeSet attrs) { this(context, attrs, 0); } public ScaledRect(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(); } private void init() { initSlop(); initLinePaint(); rectF = new RectF(); } private void initLinePaint() { linePaint = new Paint(); linePaint.setStrokeWidth(1f); linePaint.setStyle(Paint.Style.STROKE); linePaint.setColor(Color.BLUE); } private void initSlop() { final ViewConfiguration configuration = ViewConfiguration .get(getContext()); mTouchSlop = configuration.getScaledTouchSlop(); } @Override protected void onDraw(Canvas canvas) { RectF tempRectF = new RectF(rectF); tempRectF.sort(); canvas.drawRect(tempRectF, linePaint); } @Override public boolean onTouchEvent(MotionEvent event) { switch (event.getActionMasked()) { case MotionEvent.ACTION_DOWN: float currentX = event.getX(); float currentY = event.getY(); touchX = currentX; touchY = currentY; if (currentX &gt; leftX - touchWidth &amp;&amp; currentX &lt; leftX + touchWidth &amp;&amp; currentY &gt; leftY - touchWidth &amp;&amp; currentY &lt; leftY + touchWidth) { //左上角区域 position = Position.LEFT_TOP; } else if (currentX &gt; leftX + width - touchWidth &amp;&amp; currentX &lt; leftX + width + touchWidth &amp;&amp; currentY &gt; leftY - touchWidth &amp;&amp; currentY &lt; leftY + touchWidth) { //右上角区域 position = Position.RIGHT_TOP; } else if (currentX &gt; leftX - touchWidth &amp;&amp; currentX &lt; leftX + touchWidth &amp;&amp; currentY &gt; leftY + height - touchWidth &amp;&amp; currentY &lt; leftY + height + touchWidth) { //左下角区域 position = Position.LEFT_BOTTOM; } else if (currentX &gt; leftX + width - touchWidth &amp;&amp; currentX &lt; leftX + width + touchWidth &amp;&amp; currentY &gt; leftY + height - touchWidth &amp;&amp; currentX &lt; leftX + width + touchWidth) { //右下角区域 position = Position.RIGHT_BOTTOM; } else if (currentX &gt; leftX - touchWidth &amp;&amp; currentX &lt; leftX + touchWidth &amp;&amp; currentY &gt; leftY + touchWidth &amp;&amp; currentY &lt; leftY + height + touchWidth) { //左侧 position = Position.LEFT; } else if (currentX &gt; leftX + touchWidth &amp;&amp; currentX &lt; leftX + width - touchWidth &amp;&amp; currentY &gt; leftY - touchWidth &amp;&amp; currentY &lt; leftY + touchWidth) { //上方 position = Position.TOP; } else if (currentX &gt; leftX + width - touchWidth &amp;&amp; currentX &lt; leftX + width + touchWidth &amp;&amp; currentY &gt; leftY + touchWidth &amp;&amp; currentY &lt; leftY + width - touchWidth) { //右侧 position = Position.RIGHT; } else if (currentX &gt; leftX + touchWidth &amp;&amp; currentX &lt; leftX + width + touchWidth &amp;&amp; currentY &gt; leftY + height - touchWidth &amp;&amp; currentY &lt; leftY + height + touchWidth) { //下方 position = Position.BOTTOM; } else if (currentX &gt; leftX + touchWidth &amp;&amp; currentX &lt; leftX + width - touchWidth &amp;&amp; currentY &gt; leftY + touchWidth &amp;&amp; currentY &lt; leftY + height - touchWidth) { //中间区域 position = Position.CENTER; } else { //外部区域 rectF.setEmpty(); leftX = event.getX(); leftY = event.getY(); rectF.set(new RectF(currentX, currentY, currentX, currentY)); position = Position.OUTER; } break; case MotionEvent.ACTION_MOVE: switch (position) { case LEFT_TOP: rectF.left = event.getX(); rectF.top = event.getY(); break; case LEFT_BOTTOM: rectF.left = event.getX(); rectF.bottom = event.getY(); break; case RIGHT_TOP: rectF.right = event.getX(); rectF.top = event.getY(); break; case RIGHT_BOTTOM: rectF.right = event.getX(); rectF.bottom = event.getY(); break; case LEFT: rectF.left = event.getX(); break; case TOP: rectF.top = event.getY(); break; case RIGHT: rectF.right = event.getX(); break; case BOTTOM: rectF.bottom = event.getY(); break; case CENTER: //矩形内，移动矩形 float tdx = event.getX() - touchX; float tdy = event.getY() - touchY; rectF.left = leftX + tdx; rectF.top = leftY + tdy; rectF.right = rectF.left + width; rectF.bottom = rectF.top + height; break; default: //矩形外，重新绘制矩形 float dx = event.getX() - leftX; float dy = event.getY() - leftY; float absX = Math.abs(dx); float absY = Math.abs(dy); double sqrt = Math.sqrt(absX * absX + absY * absY); if (sqrt &gt; mTouchSlop) { //矩形可见 rectF.right = event.getX(); rectF.bottom = event.getY(); } break; } postInvalidate(); break; case MotionEvent.ACTION_UP: rectF.sort(); leftX = rectF.left; leftY = rectF.top; width = rectF.width(); height = rectF.height(); break; } return true; } }","tags":[{"name":"Android","slug":"Android","permalink":"http://ilancuo.com/tags/Android/"},{"name":"自定义View","slug":"自定义View","permalink":"http://ilancuo.com/tags/自定义View/"}]},{"title":"Mac下使用Flask框架开发Python","date":"2017-01-18T14:46:25.000Z","path":"2017/01/18/Mac下使用Flask框架开发Python/","text":"安装pyCharm，官网下载地址 首先安装virtualenv，命令如下： sudo easy_install virtualenv 或者 sudo pip install virtualenv 创建自己的环境： mkdir pyPro cd pyPro virtualenv venv 激活环境 . venv/bin/activate #注意：&quot;.&quot;和&quot;venv&quot;之间有一个空格 安装Flask pip install Flask 打开pyCharm，创建一个新的项目，在Interpreter后面点击齿轮按钮，选择Create VirtualEnv，选择刚刚创建目录下的.../pyPro/venv/bin/python，点击OK即可，成功之后的效果如图所示： 在pyCharm中创建Hello.py文件： from flask import Flask app = Flask(__name__) @app.route(&#39;/&#39;) def hello(): return &#39;Hello, World!&#39; app.run() 运行项目，控制台输出： /Users/ilancuo/PyPro/venv/bin/python /Users/ilancuo/PycharmProjects/FlaskTest/Hello.py * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) 表示项目运行成功，这时候打开浏览器访问： http://127.0.0.1:5000 或者 http://localhost:5000 就会在网页上显示：Hello, World!。 至此，项目配置成功。","tags":[{"name":"Python","slug":"Python","permalink":"http://ilancuo.com/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"http://ilancuo.com/tags/Flask/"},{"name":"pyCharm","slug":"pyCharm","permalink":"http://ilancuo.com/tags/pyCharm/"}]},{"title":"Android中采用xml存储map","date":"2016-12-27T12:49:23.000Z","path":"2016/12/27/Android中采用xml存储map/","text":"在strings.xml中创建如下格式的数据：&lt;string-array name=&quot;nameValue&quot;&gt; &lt;item&gt;name|Mike&lt;/item&gt; &lt;item&gt;age|18&lt;/item&gt; &lt;/string-array&gt; 使用标准的读取string数组的方式进行读取：public Map&lt;String, String&gt; getMap() { private String[] arry = getResources().getStringArray(R.array.nameValue); Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); for (String str : mari) { String[] split = str.split(&quot;\\\\|&quot;); //注意这一步，将分割线前后的两个字符串分别存储到Key和value中，分割线可自定义 map.put(split[0], split[1]); } return map; } 参考：stackoverflow","tags":[{"name":"Android","slug":"Android","permalink":"http://ilancuo.com/tags/Android/"},{"name":"xml","slug":"xml","permalink":"http://ilancuo.com/tags/xml/"},{"name":"map","slug":"map","permalink":"http://ilancuo.com/tags/map/"}]},{"title":"Android开发中常用的ADB命令","date":"2016-12-25T12:47:56.000Z","path":"2016/12/25/Android开发中常用的ADB命令/","text":"ADB命令 adb version #查看版本 adb install D:\\HelloWorld.apk #安装指定目录中的apk文件 adb -s emulator-5554 install HelloWorld.apk #安装应用到指定模拟器 adb install -r demo.apk #保留数据和缓存文件，重新安装apk adb install -s demo.apk #安装apk到SD卡 adb uninstall -k [包名] #卸载，-k为卸载软件但是保留配置和缓存文件；但是在此命令添加-k参数会报错，可以在adb shell命令中，执行pm uninstall -k [包名]实现相同的功能； adb push &lt;local&gt; &lt;remote&gt; #从本地复制文件到模拟器 adb pull &lt;remote&gt; &lt;local&gt; #从模拟器到本地 adb get-serialno #获取设备序列号 adb devices #查看可用模拟器列表 adb shell #进入Shell reboot -p #关机 [shell下命令] adb kill-server/start-server #启动、停止模拟器服务 adb logcat -s [tag] #查看LOG信息 adb shell cat /sys/class/net/wlan0/address #获取Mac地址 adb shell getprop ro.product.model #获取设备型号 adb shell getprop ro.build.version.release #查看Android系统版本 adb shell wm size #查看屏幕分辨率 adb shell wm density #查看屏幕密度 adb shell getprop ro.product.cpu.abi #查看连接手机的CPU核心 adb shell pm list packages #列出手机装的所有app的包名 adb shell pm list packages -s #列出系统应用的包名 adb shell pm list packages -3 #第三方应用的包名 adb shell pm list packages | grep qq #使用grep过滤 adb shell pm clear &lt;packagename&gt; #清除应用数据与缓存 adb shell pm list permissions #查询系统中支持的许可列表 adb shell am start -n com.ilancuo.demo/.ui.SplashActivity #启动应用 adb shell am force-stop &lt;packagename&gt; #强制停止应用 adb shell netstat -ano #查看端口占用情况，然后根据PID去任务管理器里面寻找相应的进程 adb shell dumpsys activity #ActivityManager 系统服务的相关信息，这些信息包括 Activity，Broadcast，Service 和 ContentProvider adb shell dumpsys meminfo #内存使用信息 adb shell dumpsys procstats –hours 3 #查看过去 3 小时内，进程的使用情况 android命令android list targets #查看可用的Android平台： android list avd #显示系统中全部AVD（模拟器） mksdcard命令mksdcard -l &lt;label&gt; &lt;size&gt; &lt;file&gt; #好处：可以在不同设备之间共享SD卡 SQLite命令sqlite3 [databasename].db #进入哪个数据库 sqlite&gt;.tables #显示所有的表 CMD命令netstat -a -o 5037 #查看端口占用情况 tasklist /fi &quot;pid eq 5384&quot; #查看占用该端口的应用[5384为上一步查询出来的PID]","tags":[{"name":"Android","slug":"Android","permalink":"http://ilancuo.com/tags/Android/"},{"name":"ADB","slug":"ADB","permalink":"http://ilancuo.com/tags/ADB/"}]},{"title":"Git的基本用法","date":"2016-12-14T13:04:52.000Z","path":"2016/12/14/Git的基本用法/","text":"初始化Git仓库： git init Git配置用户名和邮箱： git config --global user.name &quot;ilancuo&quot; git config --global user.email &quot;grandkingwang@gmail.com&quot; #如果只想在该项目中配置，只需要把--global参数去掉即可 查看Git配置状态： git config --list 添加到暂存 git add hello.txt #添加一个文件 #或者 git add -A #添加当前目录下的所有文件 提交 git commit -m &quot;Initial commit.&quot; 链接远端仓库 git remote add origin https://github.com/ilancuo/i.git #通常主远端仓库被起名称origin Push &amp;&amp; Pull git pull origin master #第一个参数为远端仓库的名字，第二个参数为分支的名字 git push origin master 克隆 git clone https://github.com/ilancuo/i.git 分支 git checkout -b test #该命令相当于以下两条 git branch test #创建分支 git checkout test #切换分支 git branch #查看分支 git branch -d test #删除分支 git branch merge test #合并到当前分支 回退 git reset --hard HEAD^ #回退到上一个版本 git reset --hard HEAD^^ #回退到上上个版本 git reset --hard HEAD~100 #回退到前100个版本 显示日志 git log #显示完整日志 git log --pretty=oneline #单行显示 从回退中恢复 git reflog #关掉命令行之后获取版本号 git reset --hard [版本号] #从回退中恢复 合并分支 git merge dev #将dev分支合并到master上","tags":[{"name":"Git","slug":"Git","permalink":"http://ilancuo.com/tags/Git/"}]},{"title":"Android简单使用xStream解析、封装xml","date":"2016-12-04T14:45:56.000Z","path":"2016/12/04/Android简单使用xStream解析、封装xml/","text":"需要用到xml与服务端进行通信。由于之前的json数据交换经验，首先Google的是类似Gson的直接解析数据到Bean的工具，经观察，jdk中含有JAXBContext，在Java环境中测试通过之后，将测试用例迁移到Android环境下，报了个NoClassDefFoundError，后来在StackOverFlow上发现此路不通。后来又看到了推荐的XStream，经测试在1.4.8+的版本中也测试不通，可能是版本兼容性的问题，换成1.4.7版本之后，竟然测试通过了。下面是详细的过程： 在build.gradle中添加依赖：compile (&#39;com.thoughtworks.xstream:xstream:1.4.7&#39;) { exclude group: &#39;xmlpull&#39;, module: &#39;xmlpull&#39; } 建立相应的实体类： public class User { private String username; private String password; private String email; public User(String username, String password, String email) { this.username = username; this.password = password; this.email = email; } // Getter、Setter方法 } 直接调用相应的转换方法： User user = new User(&quot;ilancuo&quot;, &quot;123456&quot;, &quot;ilancuo@ilancuo.com&quot;); XStream xStream = new XStream(); String xml = xStream.toXML(user); Log.e(TAG, xml); 输出结果为： &lt;com.ilancuo.xstreamtest.User&gt; &lt;username&gt;ilancuo&lt;/username&gt; &lt;password&gt;123456&lt;/password&gt; &lt;email&gt;ilancuo@ilancuo.com&lt;/email&gt; &lt;/com.ilancuo.xstreamtest.User&gt; 到这一步为止，实现了从xml到JavaBean的转化。但是由于.Net写的后台，后台要求，根节点不能带包名，并且字段很多是”User.Name”和”User.Password”形式的，但是Java实体类中不能出现这样的属性，只好继续Google。发现可以重新给设置xml中属性的名称： xStream.alias(&quot;User&quot;, User.class); //根节点名称 xStream.aliasField(&quot;User.Name&quot;, User.class, &quot;username&quot;); xStream.aliasField(&quot;User.Password&quot;, User.class, &quot;password&quot;); xStream.aliasField(&quot;User.Email&quot;, User.class, &quot;email&quot;); 输出结果： &lt;User&gt; &lt;User.Name&gt;ilancuo&lt;/User.Name&gt; &lt;User.Password&gt;123456&lt;/User.Password&gt; &lt;User.Email&gt;ilancuo@ilancuo.com&lt;/User.Email&gt; &lt;/User&gt; 完美那个单词怎么说来着？Perfect！可以来个简单的封装了。老规矩，先看协议文档，忽然发现，有两个接口返回的每个字段都是“User.Name”形式的，心里暗暗骂了一遍.Net写的后台。并且“xStream.aliasField”是什么鬼？重复性的工作，简直是对程序员的侮辱！可不可以给每个属性都加个注解呢？好吧，继续Google……终于，皇天不负有心人，这时候，我们的User类是这样的了： @XStreamAlias(&quot;User&quot;) public class User { @XStreamAlias(&quot;User.Name&quot;) private String username; @XStreamAlias(&quot;User.Password&quot;) private String password; @XStreamAlias(&quot;User.Email&quot;) private String email; public User(String username, String password, String email) { this.username = username; this.password = password; this.email = email; } // Getter、Setter方法 } 调用的时候只需要这样就行了 XStream xStream = new XStream(); xStream.autodetectAnnotations(true); xStream.processAnnotations(User.class); String xml = xStream.toXML(user); Log.e(TAG, xml); 此时，输出的结果为： &lt;User&gt; &lt;User.Name&gt;ilancuo&lt;/User.Name&gt; &lt;User.Password&gt;123456&lt;/User.Password&gt; &lt;User.Email&gt;gradnkingwang@gmail.com&lt;/User.Email&gt; &lt;/User&gt; 现在才是真正的完美嘛！但是总感觉少了点什么，继续翻协议文档。我擦，xml头没有。好吧，果断字符串拼接啊！有没有更吊的方法呢？还真被我找到了。直接写一个类，继承XStream，然后重写toXML()方法即可。```import com.thoughtworks.xstream.XStream;import com.thoughtworks.xstream.io.xml.DomDriver; import java.io.IOException;import java.io.OutputStream;import java.io.Writer; /** XStream扩展* Created by ilancuo on 2016/11/29.*/public class XStreamImpl extends XStream { public XStreamImpl() { super(new DomDriver(&quot;utf-8&quot;)); } public String getDeclaration() { return &quot;&lt;?xml version=\\&quot;1.0\\&quot; encoding=\\&quot;utf-8\\&quot; ?&gt;\\n&quot;; } @Override public void toXML(Object obj, OutputStream out) { try { String dec = this.getDeclaration(); byte[] byteDec = dec.getBytes(); out.write(byteDec); } catch (IOException e) { e.printStackTrace(); } super.toXML(obj, out); } @Override public void toXML(Object obj, Writer out) { try { out.write(getDeclaration()); } catch (IOException e) { e.printStackTrace(); } super.toXML(obj, out); }} 额，还是拼接。不过，不要在意这些细节。 最后一步，简单进行地封装一下： import com.thoughtworks.xstream.XStream; /** XStream解析器* Created by ilancuo on 2016/11/29.*/public class XStreamParser { private static XStreamParser instance; private XStream xStream; private XStreamParser() { xStream = new XStreamImpl(); xStream.autodetectAnnotations(true); } public static XStreamParser getInstance() { if (instance == null) { synchronized (XStreamParser.class) { if (instance == null) { instance = new XStreamParser(); } } } return instance; } public String toXML(T t) { xStream.processAnnotations(t.getClass()); return xStream.toXML(t); } public T fromXML(String xml) { return (T) xStream.fromXML(xml); }}```欢迎各位雅正。","tags":[{"name":"Android","slug":"Android","permalink":"http://ilancuo.com/tags/Android/"},{"name":"xml","slug":"xml","permalink":"http://ilancuo.com/tags/xml/"},{"name":"xStream","slug":"xStream","permalink":"http://ilancuo.com/tags/xStream/"}]}]